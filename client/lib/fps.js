// === FPS(帧频)：每秒帧数 === //
// === 1 检测： === //
// === 1.1 开发者工具：More tools -> Rendering -> FPS meter === //
// === 1.2 Frame Timing API: Web Performance Timing API中的一员，兼容性不行 === //
// === 1.3 requestAnimationFrame: 每动画循环一次，帧数自增1；1s后用帧数除以时间间隔则得出fps === //

// === 位运算: === //


// === 源码/反码/补码: === //
// === 1 机器数: 一个数在计算机中的二进制表示形式,  叫做这个数的机器数。机器数是带符号的，在计算机用一个数的最高位存放符号, 正数为0, 负数为1. === //
// === 1.1 例子: 十进制中的数 +3 ，计算机字长为8位，转换成二进制就是00000011。如果是 -3 ，就是 10000011; 那么，这里的 00000011 和 10000011 就是机器数  === //
// === 2 真值: 因为第一位是符号位，所以机器数的形式值就不等于真正的数值。例如上面的有符号数 10000011，其最高位1代表负，其真正数值是 -3 而不是形式值131（10000011转换成十进制等于131）。所以，为区别起见，将带符号位的机器数对应的真正数值称为机器数的真值 === //
// === 2.1 例子: 0000 0001的真值 = +000 0001 = +1，1000 0001的真值 = –000 0001 = –1 === //
// === 3 原码: 原码就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值. 比如如果是8位二进制 === //
// === 3.1 例子: === //
/*
[+1]原 = 0000 0001
[-1]原 = 1000 0001
第一位是符号位. 因为第一位是符号位, 所以8位二进制数的取值范围就是: [1111 1111 , 0111 1111] 即[-127 , 127]
原码是人脑最容易理解和计算的表示方式.
*/
// === 4 反码: 正数的反码是其本身, 负数的反码是在其原码的基础上, 符号位不变，其余各个位取反 === //
// === 4.1 例子: === //
/*
[+1] = [00000001]原 = [00000001]反
[-1] = [10000001]原 = [11111110]反
可见如果一个反码表示的是负数, 人脑无法直观的看出来它的数值. 通常要将其转换成原码再计算.
*/
// === 5 补码: 正数的补码就是其本身, 负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1) === //
// === 5.1 例子: === //
/*
[+1] = [00000001]原 = [00000001]反 = [00000001]补
[-1] = [10000001]原 = [11111110]反 = [11111111]补
对于负数, 补码表示方式也是人脑无法直观看出其数值的. 通常也需要转换成原码在计算其数值.
*/

// 1s内帧数
let frame = 0
// 上次计算fps时的时间
let lastTime = 0

/**
 * 计算fps
 * @return {Numner} - fps
 */
export default function () {
  const now = Date.now()

  ++frame

  let fps = 0

  // 检测是否自上次检测后过了1s
  if (now >= 1000 + lastTime) {
    // 乘以1000，由ms换算成s
    fps = (frame * 1000) / (now - lastTime) | 0

    // 重置
    frame = 0
    lastTime = now

    return fps
  }
}
