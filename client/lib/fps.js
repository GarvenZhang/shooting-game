// === FPS(帧频)：每秒帧数 === //
// === 1 检测： === //
// === 1.1 开发者工具：More tools -> Rendering -> FPS meter === //
// === 1.2 Frame Timing API: Web Performance Timing API中的一员，兼容性不行 === //
// === 1.3 requestAnimationFrame: 每动画循环一次，帧数自增1；1s后用帧数除以时间间隔则得出fps === //

// === 位运算: === //
// === 1 位操作符: === //
// === 1.1 按位非(~): 返回数值的反码 === //
// === 1.2 按位与(&): 按位与操作只在两个数值的对应位都是 1 时才返回 1 === //
// === 1.3 按位或(|): 只有在两个位都是 0 的情况下才返回 0 === //
// === 1.4 按位抑或(^): 对应的两位都是 1 或都是 0，则返回 0 === //
// === 1.5 左移(<<): 将数值的所有位向左移动指定的位数(左移不会影响操作数的符号位), 补零=== //
// === 1.6 有符号的右移(>>): 将数值向右移动，但保留符号位, 补零 === //
// === 1.7 无符号的右移(>>): 所有位右移，补零 === //
// === 2 应用: === //
// === 2.1 整数乘/除2的倍数: === //
/*
24 << 2 == 24 * 4
32 >> 3 == 32 / 8
*/
// === 2.2 随机整数: === //
/*
var ran = Math.random()
alert("a: " + ((ran * 5) | 0)) // rang = 0 - 4
alert("a: " + ((ran * 5) | 1)) // rang = 1 - 5
*/
// === 2.3 奇偶判断: === //
/*
for(let i = 0; i < 10; i++){
  (i & 1)&& console.log(`${i} is odd!`)
}
*/
// === 2.4 浮点数取整: 其实浮点数是不支持位运算的，所以会先把1.1转成整数1再进行位运算，就好像是对浮点数向下求整。所以1|0的结果就是1 === //
/*
const num = 1.1 | 0; // 1
3.14159 >> 0 = 3
*/
// === 2.5 无需第三方来将两个数值互换: === //
/*
// 我们经常会需要调换两个数字的值：
var num1 = 1, num2 = 2, temp
temp = num1
num1 = num2 // 2
num2 = temp // 1

//如果装逼一点的话，可以这样：
var num1 = 1, num2 = 2
num1 = [num2, num2 = num1][0]
console.log(num1) // 2
console.log(num2) // 1

//如果想再装的稳一点的话，可以这样：
var num1 = 1, num2 = 2
num1 ^= num2 // num1 = num1 ^ num2 = 1 ^ 2 = 3
num2 ^= num1 // num2 = num2 ^ (num1 ^ num2) = 2 ^ (1 ^ 2) = 1
num1 ^= num2 // num1 = num1 ^ num2 = 3 ^ 1 = 2
console.log(num1) // 2
console.log(num2) // 1
*/
// === 2.6 求2的n次方: 1的二进制是01，左移5位就是0100000，十进制就是2的5次方32 === //
/*
function power(n) {
    return 1 << n
}
power(5) // 32
*/
// === 2.7 求2的n分一次方: === //
/*
//求一个数的二分之一：
var num = 64 >> 1 // 32
*/
// === 2.8 利用无符号右移来判断一个数的正负: === //
/*
function isPos(n) {
    return n === (n >>> 0)
}
isPos(-1) // false
isPos(1) // true
// -1 >>> 0 虽然没有向右移动位数，但-1的二进制码已经变成了正数的二进制码
// 所以-1 >>> 0的值为 4294967295
*/

// === 源码/反码/补码: === //
// === 1 机器数: 一个数在计算机中的二进制表示形式,  叫做这个数的机器数。机器数是带符号的，在计算机用一个数的最高位存放符号, 正数为0, 负数为1. === //
// === 1.1 例子: 十进制中的数 +3 ，计算机字长为8位，转换成二进制就是00000011。如果是 -3 ，就是 10000011; 那么，这里的 00000011 和 10000011 就是机器数  === //
// === 2 真值: 因为第一位是符号位，所以机器数的形式值就不等于真正的数值。例如上面的有符号数 10000011，其最高位1代表负，其真正数值是 -3 而不是形式值131（10000011转换成十进制等于131）。所以，为区别起见，将带符号位的机器数对应的真正数值称为机器数的真值 === //
// === 2.1 例子: 0000 0001的真值 = +000 0001 = +1，1000 0001的真值 = –000 0001 = –1 === //
// === 3 原码: 原码就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值. 比如如果是8位二进制 === //
// === 3.1 例子: === //
/*
[+1]原 = 0000 0001
[-1]原 = 1000 0001
第一位是符号位. 因为第一位是符号位, 所以8位二进制数的取值范围就是: [1111 1111 , 0111 1111] 即[-127 , 127]
原码是人脑最容易理解和计算的表示方式.
*/
// === 4 反码: 正数的反码是其本身, 负数的反码是在其原码的基础上, 符号位不变，其余各个位取反 === //
// === 4.1 例子: === //
/*
[+1] = [00000001]原 = [00000001]反
[-1] = [10000001]原 = [11111110]反
可见如果一个反码表示的是负数, 人脑无法直观的看出来它的数值. 通常要将其转换成原码再计算.
*/
// === 5 补码: 正数的补码就是其本身, 负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1) === //
// === 5.1 例子: === //
/*
[+1] = [00000001]原 = [00000001]反 = [00000001]补
[-1] = [10000001]原 = [11111110]反 = [11111111]补
对于负数, 补码表示方式也是人脑无法直观看出其数值的. 通常也需要转换成原码在计算其数值.
*/

// 1s内帧数
let frame = 0
// 上次计算fps时的时间
let lastTime = 0

/**
 * 计算fps
 * @return {Numner} - fps
 */
export default function () {
  const now = Date.now()

  ++frame

  let fps = 0

  // 检测是否自上次检测后过了1s
  if (now >= 1000 + lastTime) {
    // 乘以1000，由ms换算成s
    fps = (frame * 1000) / (now - lastTime) | 0

    // 重置
    frame = 0
    lastTime = now

    return fps
  }
}
